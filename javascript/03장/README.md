# 동기와 비동기 처리
![hh3Mawr](https://user-images.githubusercontent.com/94473725/194252738-d25ae1b0-7f65-4cc2-9003-e9fbe31cf3cd.png)



## **동기처리**

: 현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식.

**장점**  태스크를 순서대로 하나씩 처리하므로 **실행 순서가 보장**됨

**단점**  앞선 태스크가 종료할 때까지 이후 태스크들이 **블로킹** 됨

함수를 호출하면 함수 코드가 평가되어 `함수 실행 컨텍스트`가 생성됨. (23장 참고!)

이때 생성된 `함수 실행 컨텍스트`는 `실행 컨텍스트 스택`(콜 스택)에 푸시(push)되고 함수 코드가 실행.

함수 코드 실행이 종료되면 `함수 실행 컨텍스트`는 `실행 컨텍스트 스택`에서 팝(pop)되어 제거.

```jsx
// 스택 자료구조인 실행 컨텍스트 스택에 푸시되어 실행됨을 보여주는 예제
const foo = () => {};
const bar = () => {};

foo();
bar();
```

> **함수 실행 과정**
> 
> 
> “함수 코드 평가 과정” 👉 `함수 실행 컨텍스트` 생성됨 👉 `실행 컨텍스트 스택`에 푸시 (함수 실행 시작!)
> 

<aside>
💡 **함수가 호출된 순서대로 실행되는 이유?**
함수가 호출된 순서대로 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되기 때문.

</aside>

❗️ **함수의 실행 순서**는 `실행 컨텍스트 스택`으로 관리한다.

⭐️ **자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 가짐.**

함수를 실행할 수 있는 창구가 단 하나, 동시에 2개 이상의 함수를 동시에 실행할 수 없다는 것을 의미.

`실행 컨텍스트 스택`의 최상위 요소인 “실행 중인 실행 컨텍스트”를 제외한 모든 실행 컨텍스트는 모두 실행 대기 중인 태스크들.

대기 중인 태스크들은 현재 실행 중인 실행 컨테스트가 팝(pop())되어 `실행 컨텍스트 스택`에서 제거되면

즉, 현재 실행 중인 함수가 종료하면 다음 태스크가 실행됨.

**JS 엔진은 한번에 하나의 태스크만 실행할 수 있는 싱글 스레드 방식으로 동작.**

한 번에 하나의 태스크만 실행할 수 있기 때문에 처리하는데 시간이 걸리는 태스크를 실행하는 경우 블로킹(작업 중단)이 발생.

```jsx
/*
setTimeout 함수와 유사하게 일정 시간이 경과한 후,
콜백 함수 호출하는 sleep 함수
*/

function sleep(func, delay){
	// Date.now() : 현재 시간을 ms로 반환
	const delayUntil = Date.now()+delay;
	// Date.now()에 delay를 더한 delayUntil이 현재 시간보다 작으면 계속 반복
	while (Date.now() < delayUntil);
	// delay 지난 후, 콜백 함수 호출
	func();
}

function foo(){
	console.log('foo');
}

function bar(){
	console.log('foo');
}

// sleep 함수는 3초 이상 실행
sleep(foo, 3 * 1000);
// bar 함수는 sleep 함수 실행이 종료된 후 호출되므로 3초 이상 강제(?) 블로킹..ㅠ
bar();
// 3초 경과 후 foo호출 -> bar 호출
```

👉 **결과** : sleep 함수는 3초 후에 foo함수를 호출.

bar 함수는 sleep 함수의 실행이 종료된 이후에 호출되므로 3초 이상 호출되지 못하고 블로킹됨.

---

## 비동기 처리

: 현재 실행 중인 태스크가 종료 되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식

**장점**  현재 실행 중인 태스크가 종료되지 않은 상태여도 다음 태스크를 곧바로 실행하므로 블로킹 발생하지 않음.

**단점**  태스크의 실행 순서가 보장되지 않음

```jsx
function foo(){
	console.log('foo');
}
function bar(){
	console.log('bar');
}

// 타이머 함수 setTimeout은 일정 시간이 경과한 이후, 콜백 함수 foo 호출
// 타이머 함수 setTimeout은 bar 함수를 블로킹 하지 않음.
setTimeout(foo, 3*1000);
bar();
```

### **setTimeout 함수**

sleep 함수와 유사하게 일정 시간이 경과한 이후에 콜백 함수를 호출하지만, setTimeout 함수 이후의 태스크를 블로킹 하지 않고 곧바로 실행한다.

비동기 처리를 수행하는 비동기 함수는 전통적으로 `콜백 패턴`을 사용

- 콜백 헬을 발생시켜 가독성을 나쁘게 함
- 비동기 처리 중 발생한 에러의 예외 처리가 곤란,
- 여러 개의 비동기 처리를 한 번에 처리하는데도 한계

👉 **Promise를 사용하면 코드의 깊이가 깊어지는 것 방지**

![FDzn5s0](https://user-images.githubusercontent.com/94473725/194253284-12568016-c3c9-4553-8dc1-a4ff66d0a504.png)


콜백 헬에 빠진 모습 ,,,

**타이머 함수인 setTimeout, setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작.**

비동기 처리는 이벤트 루프와 태스크 큐와 관계됨.

이건 다음 내용으로 ,, 총총 ,,
